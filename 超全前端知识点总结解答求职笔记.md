[TOC]

# 1.      单页面应用

单页面，只有一个主页面的应用，浏览器一开始就加载所有的资源，所有的页面都包含在主页面中，跳转只刷新局部资源，不向服务器发送请求。

多页面，一个应用中有多个页面，跳转的时候会重新请求服务器。

单页面优点：用户体验好，页面切换流畅，前后端分离（后端不用再负责模板渲染输出工作只需专注自身API开发和程序逻辑处理），服务器压力小（只要提供数据不用管展示逻辑和页面合成），容易添加各种转场动画

缺点：不利于搜索引擎优化（SEO爬虫只爬取源码，不执行脚本语句），初次加载耗时长，页面复杂度高

# 2.      数据结构

**数组**

顺序存储，内存分配是连续的，元素通过下标访问。

按照索引查询元素快，遍历数组方便，适合查询遍历，不适合添加删除



**链表**

非连续、非顺序的存储结构，逻辑顺序通过链表指针实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域，动态分配内存。

适合添加删除，不适合遍历，查找需要遍历整个链表，存在大量指针域，消耗空间

js链表实现：https://www.cnblogs.com/tdws/p/6033209.html

https://segmentfault.com/a/1190000017569816

 

**栈、队列**

用队列实现栈，用栈实现队列

<https://segmentfault.com/a/1190000018650785>

 

**树**

结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。

分类：二叉查找树（左比根小，右比根大）平衡二叉树(左右子树的高度相差不大于1) 完全二叉树（n个结点的深度为Math.floor(Math.log2(n)) + 1）满二叉树

深度优先：深度优先可分为前序遍历，中序遍历，以及后序遍历，都是先进行深层次某个节点的遍历，直到为空，然后再往上遍历其兄弟节点。深度优先一般采用递归的方式实现，递归的深度为树的高度。非递归用栈实现。

广度优先：广度优先是按照层次来遍历树的节点，先是根节点，然后依次遍历第二层子节点，当第二层子节点遍历完后，在依次遍历第三层子节点。采用队列实现

# 3.      算法

算法特性：有穷性，确切性，可行性

# 4.     Vue中 static、assets区别

static必须使用绝对路径，不会被webpack打包，通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 链接来确定。assets路径要经过webpack中的file-loader编译，路径不能直接写。一般在static里放一些类库的文件，assets放属于项目的资源文件。

# 5.      跨域

同源策略：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性

<https://segmentfault.com/a/1190000012469713?utm_source=tag-newest>

JSONP

原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。只支持GET请求。

 

CORS

<https://www.cnblogs.com/lazyInsects/p/8110758.html>

 

node.js中间件

# 6.      git github

初始化：git init

添加文件：git add filename    git add folder/

git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件

git add -A  提交所有变化

删除：git rm filename    git rm -r folder/

提交： git commit –m “message   

git commit   --amend        撤销上一次提交  并将暂存区文件重新提交

拉取远程仓库：

 $ git clone url

 $ git clone -b branchName url 拉取分支

本地初始化提交远程仓库：

 $ git remote add origin https://github.com/Lindsayyyy/gitlearn

 $ git push -u origin master 第一次加u

更新本地仓库  git pull 更新之前注意所在分支

分支：

$ git branch dev 创建

$ git checkout dev 切换

$ git checkout -b dev 上两条git的合并

$ git branch 查看

$ git branch -r 查看远程分支

$ git merge [name] 合并

$ git branch -d [name]  删除本地

$ git push origin ：远程分支 删除远程

提交到远程分支

$ git push origin may:may （本地分支：远程分支 ）

其他git status    git diff   git log

# 7.      字符串、数组等常用js方法

【字符串】str.方法

charAt(index)：返回指定索引位置的字符串，超出为空字符

indexOf(字符串）：字符串开始的索引值，没有返回-1，查找第一个符合的

lastIndexOf(字符串）：从后往前找，查找第一个符合的

replace()：str.replace(/\s+/g, '%20')，str.replace(/Microsoft/g, "W3School")

concat()   slice()   split()   substr(start, num)  substring(start, end)：不包括结束

toLocaleLowerCase();转小写   toLowerCase();转小写

toLocaleUpperCase()转大写    toUpperCase();转大写

num.toString(16) 十进制转十六进制

 

【数组】

concat()：arr.concat(arr1)，arr.concat('1', '2')，**返回连接的新数组**

slice(start, end)：不包含end，**返回一个新数组**

splice(start, delnum, add序列)，返回被删除的元素，**改变数组**

every(func)：方法用于检测数组所有元素是否都符合指定条件（通过函数提供），arrs.every(function (item) { return item > 0})，检测所有元素，只有全部符合才会返回true，一旦检测到不符合就返回false，不再检测接下来的

some(func)，只要一个符合就行

filter(func)：，返回符合要求的元素数组，**新数组**

push()

pop()：删除最后一个

shift()：删除第一个元素并返回这个元素

unshift()：第一个元素前面插入一个新的元素，返回新的长度

forEach(func)：遍历，相当于for循环，把每一个元素放入回调函数执行

join()：array.join(separator)。默认逗号

map()：array.map(function(currentValue,index,arr), thisValue)，返回**新数组**

reverse()：array.reverse() 逆序str.split('').reverse().join('')

sort()：points.sort(function(a,b){return a-b});用来简化for循环

 

array的方法

会改变原数组：reverse(),shift(),splice(),unshift()

不会改变原数组：concat(),slice(),filter(),map()

# 8.      隐式类型转换

字符串连接符，算术运算符，关系运算符

https://blog.csdn.net/itcast_cn/article/details/82887895

# 9.      Math运算

四舍五入 Math.round(5/2)　　// 3

Math.min.apply(Math, arr)

Math.PI----π---

Math.E----常数的底数

Math.abs(值)-----绝对值

Math.ceil(值)----向上取整 向上取整,有小数就整数部分加1 Math.ceil(5/2)　　// 3

Math.floor(值)---向下取整 向下取整,丢弃小数部分 Math.floor(5/2)　　// 2

# 10. 数据类型及校验

基本类型：Number Boolean  String  undefined null Symol(ES6)

引用类型：Object  Function Array Date

 

typeof value(声明但未赋值)  // undefined

typeof NaN  // number"

typeof null // object

typeof arr  // object

typeof 引用类型  // 都是object

typeof 运算符可返回以下原始类型之一：string  number  Boolean  undefined

typeof 运算符可返回以下两种复杂数据类型之一：function   object

 

isNaN方法但是如果是空格或字符串，就会当做0处理

 

**null undefined**

Undefined 与 null 的值相等，但类型不相等, null表示一个对象不存在，即“没有对象”；undefined表示基本类型或对象的值没被定义，也就“缺少值”

typeof undefined              // undefined

typeof null                   // object

null === undefined            // false

null == undefined             // true

 

Number()：任何类型转数值，null=0，undefined=NaN

parseInt()：转换成整数，第一个不为数组或正负号返回NaN

parseFloat()：只能处理十进制数

 

判断一个对象是不是数组

1、Array.isArray(arr) ES5

2、Object.prototype.toString().call(arr)  '[object Array]'

3、arr instanceof Array

4、a.constructor === Array

 

1、  typeof val 检测数据类型

只能校验出四种数据类型（不包括null,null是空指针）及object，function

NaN=number，null=object， function=function，object,array,data,null=object

2、  instanceof 检测一个实例是否属于某个类

主要用来弥补typeof不能检测具体属于哪个对象的局限性，不能检测原始数据类型

  console.log(arr instanceof Array);  //true

  console.log(arr instanceof Object);  //true

  console.log(reg instanceof RegExp);  //true

  console.log(reg instanceof Object);  //true

3、  constructor 构造函数

4、  Object.prototype.toString.call(data) 原型链上的Object对象的toString方法

Object.prototype.toString.call('aaaa')  // [object String]

toString为Object的原型方法，而Array 、Function等类型作为Object的实例，都重写了toString方法。

# 11. 伪数组

伪数组，一个对象，有length属性，可以通过下标访问，如果这个对象的length不为0，那么这个对象一定有(length-1)为下标的属性值。

没有数组的方法，可以转化为标准数组，比如函数中的arguments对象(函数的实参集合)。

转换为真数组，arr = Array.prototype.slice.call(arguments)

# 12. DOM结构及操作

【DOM结构】

当前对象为node，document.getElementById("item1").node……

返回父节点：node.parentNode, node.parendElement, 

返回所有子节点：node.childNodes（包含文本节点及标签节点）,node.children（只有元素节点）

返回第一个子节点：node.firstChild 

返回最后一个子节点： node.lastChild 

node.nodeType   //1元素节点element， 2属性节点attr，3文本节点text， 11documentFragment

【DOM操作】

（1）创建新节点

  createDocumentFragment()    // 创建一个DOM片段

  createElement()   //创建一个具体的元素

  var a = document.createElement("a"); 

    a.href = url; 
    
    a.innerHTML = text; 
    
    a.style.color = "red"; 
    
    o.appendChild(a); 
    
    } 
    
    createTextNode()   //创建一个文本节点，document.createTextNode("test")
    
    getAttribute()
    
    setAttribute()
    
    document.getElementById("first").style.fontSize = "18px";（样式驼峰命名）;
    
    document.getElementById("first").className = "class1";
    
    document.getElementById("first").setAttribute("class","class1");
    
    document.getElementById("first").setAttribute("style","color:red;");

（2）添加、移除、替换、插入

      appendChild(新节点)
    
      removeChild(子节点) 删除成功返回该被删除的节点，否则返回null
    
      replaceChild(新节点，老节点)
    
      insertBefore(新节点，目标节点)

（3）查找

      getElementsByTagName()    //通过标签名称
    
      getElementsByName()    //通过元素的Name属性的值 ..ByClassName('c')
    
      getElementById()    //通过元素Id，唯一性

querySelectorAll：返回Static Node List，属于 Selectors API， document.querySelectorAll('.b1 .c'); 严格符合 CSS 选择符规范

getElementsByTagName：返回 Live Node List， 属于W3C的DOM规范。动态节点，更新节点后会重新调整DOM结构

# 13. 伪类选择器

<https://www.cnblogs.com/ndos/p/8299464.html>

# 14. 块元素行内元素

　行内元素inline，a b span img input select strong input

　行内元素特征：(1)设置宽高无效，可以设置line-height(2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效 (3)不会自动进行换行

　块状元素block，div、p、nav、aside、header、footer、section、article、ul-li、address、div ul ol li dl dt dd h1 h2 h3 h4…p等等，都可以用div来实现。

   块状元素特征：(1)能够识别宽高(2)margin和padding的上下左右均对其有效(3)可以自动换行(4)多个块状元素标签写在一起，默认排列方式为从上至下

   行内块元素inline-block，元素排在一行，支持所有样式

# 15. 浮动造成的原因及解决方法

浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

浮动元素引起的问题：

（1）父元素的高度无法被撑开，影响与父元素同级的元素

（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后

（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

（4）文字环绕

 

清除浮动的几种方法：

    1，额外标签法，<div style="clear:both;"></div>（所有浮动标签后面添加一个空标签，缺点增加额外的标签使HTML结构看起来不够简洁。）
    
    2，使用after伪元素
    
    \#parent::after{
    
        height:0; // 必须
    
        display:block;
    
        clear:both;
    
        }
    
    3,给父元素设定高度
    
    4,设置父元素overflow为hidden或者auto（BFC）

# 16. 水平垂直居中实现

Flex（justify-content align-items）

已知宽高，使用绝对数值实现（绝对定位，margin-left,margin-top）

transform:translate(-50%,-50%)（相对于自身宽高）

父元素是块级元素，子元素是行内元素，父元素text-align:center，子元素line-height为父元素高度

# 17. web storage和cookie的区别

1、Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。2、Cookie的大小和数量有限制。localStorage和sessionStorage的容量较大，为5M。

3、cookie也是不可或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生

4、localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等。sessionStorage是会话级别的，当前标签页关闭后信息就会清楚。localStorage没有失效时间，只能通过手动的方式清除。

5、cookie的过期时间默认为当前会话结束，可以自己设置。

6、webStorage发生变化可以监听，window.addEventListener('storage')

# 18. cookie 和session 的区别：

 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。

 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。

 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

 5、将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中

6、session中保存的是对象，cookie中保存的是字符串

# 19. 对前端模块化的认识

将一个复杂的程序依据一定的规则（规范）封装成几个块（文件）并进行组合。模块的内部数据的实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信。

模块化可以降低代码耦合度，避免全局变量污染，使项目结构更清晰。

 

**IIFE（自执行函数）**

避免全局污染，使用闭包。

缺点：本质来说，还是按照从上至下的顺序执行脚本，无法管理脚本间的依赖，必须手动维护script标签的顺序。

(function(window) {

    window.jQuery = {
    
       // 这里是代码 
    
    };

})(window);

 

**AMD(Asynchronous Module Definition) 浏览器**

提供异步加载功能，该规范原生Javascript无法支持，ReaquireJS是实现该规范的类库。

特点：提前预加载，提前执行，导入解析模块的时候，会先加载对应的依赖模块，再执行接下来的代码，AMD模块可以并行加载所有依赖模块

define('./index.js',function(code){

    // code 就是index.js 返回的内容
    
    return {
    
        sayHello: function(name) {
    
            return "Hello, " + name;
    
        }
    
    }

});

 

**CMD(Common Module Definition) 浏览器**

阿里提出的，由SeaJS库实现

特点：依赖就近，延后执行。加载完模块后不执行，只下载，在所有依赖模块加载完成后进入主逻辑，遇到require语句再执行对应的模块，这样模块的执行顺序和书写顺序就是完全一致的。require.async()方法，可以实现模块的懒加载。

define(function(require) {

   //通过require引用模块

   var path=require.resolve('./cmdDefine');

   alert(path);

});

 

**CommonJS 服务端**

NodeJS采用的规范。在Node.js中，内置了module对象用来定义模块, require函数用来加载模块文件。

特点：

1、同步阻塞加载，无法实现按需加载。加载完才能执行后面的操作。这是服务器段规范，想在浏览器中使用需要Browserify解析。

npm install browserify -g

browserify utils.js >　bundle.js

2、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。

3、模块加载的顺序，按照其在代码中出现的顺序。

// utils.js 模块定义

var add = function(a, b) {

    return a + b;

};

module.exports = {

    add: add

};

// 加载模块

var utils = require('./utils');

console.log(utils.add(1, 2));

 

**ES6模块化**

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

ES6从语法层面提供了模块化功能，需要babel等工具进行编译。ES6提供了import和export命令，分别对应模块的导入和导出功能。

1、import是静态执行，不能使用表达式和变量。不能使用在运行中才能得到的语法结构

2、export default输出一个叫default的变量或方法，引入的时候可以指定任意名字，export、import不需要加括号，因为一个模块只能有一个默认输出

3、一个文件一个依赖

4、ES6模块的API是静态的，一旦导入，无法再在程序运行过程中添加方法。采用引用绑定，如果在模块运行中修改了导出的变量值会反映到模块中去。存在动态更新，如定时器，会实时更新

5、单例模式，每次对同一个模块的导入都指向同一个实例。

6、ES6不支持按需加载，借助webpack的require.ensure API

// demo-export.js 模块定义

var name = "scq000"

var sayHello = (name) => {

  console.log("Hi，" + name);

}

export {name, sayHello};

 

// demo-import.js 使用模块

import {sayHello} from "./demo-export";

sayHello("scq000");

 

**ES6 CommonJS区别**

1、CommonJS 模块输出的是一个值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值，除非是函数内部的值。ES6 模块输出的是值的引用。

2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

 

# 20. Webpack

<https://segmentfault.com/a/1190000006178770>

Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。

![webpack](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/webpack.png)                                        

# 21. 创建ajax过程

(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

    const client = new XMLHttpRequest();
    
    client.open("GET", url,true); //第三个参数：是否是异步
    
    client.onreadystatechange = handler;
    
    client.responseType = "json";
    
    client.setRequestHeader("Accept", "application/json");
    
    client.send();



$.ajax({

 type:"get",// get或者post

 url:"abc.php",// 请求的url地址

 data:{},//请求的参数

 dataType:"json",//json写了jq会帮我们转换成数组或者对象 他已经用JSON.parse弄好了 

 timeout:3000,//3秒后提示错误

 beforeSend:function(){ 

 // 发送之前就会进入这个函数

 // return false 这个ajax就停止了不会发 如果没有return false 就会继续

 },

 success:function(data){ // 成功拿到结果放到这个函数 data就是拿到的结果

 },

 error:function(){//失败的函数

 },

 complete:function(){//不管成功还是失败 都会进这个函数

 }

})

**axios+promise**

checkLogin: () => {

// 返回一个promise对象

    return new Promise((resolve, reject) => {
    
      axios({
    
            url: url
    
            method: 'post',
    
            data: {
    
            }
    
          })
    
            .then((res) => {
    
              resolve(res.data);
    
              // console.log(res);
    
            })
    
            .catch(function (error) {
    
              reject(error);
    
              // console.log(error);
    
            });
    
    });

  }

this.common.checkLogin()

              .then(res => {
    
                console.log(res);
    
                  // 执行成功的回调函数
    
              },kuayu
    
              error => { console.log(error); 
    
              // 执行失败的回调函数
    
              });

# 22. web攻击

1、XSS(Cross-Site Scripting)，跨站脚本攻击

http://192.168.1.102/xss/example4.php?name=<img src='w.123' onerror='alert("hey!")'>

<div onmouseover=‘do something here’>

原理：插入恶意可执行网页脚本代码

预防措施：

1、Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。

2、用户输入转译。

3、尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。

4、尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。

5、http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开

2、CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。

防御

1、referer验证：禁止来自第三方的请求，HTTP请求头的Referer域中记录着请求来源，通过检查请求来源，验证是否合法

2、禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（所有的第三方请求都不能携带本网站的cookie）和Lax（链接可以，但是form表单提交和ajax请求不行）

3、SQL注入攻击

4、网络劫持

5、控制台引诱输入

# 23. vuex数据传输流程

　1、通过new Vuex.Store()创建一个仓库 state是公共的状态

　2、在组件内部通过this.$store.state.属性 来调用公共状态中的state，进行页面的渲染。

　3、当组件需要修改数据的时候，必须遵循单向数据流。通过this.$store.dispatch来触发actions中的方法

　4、actions中的每个方法都会接受一个对象 这个对象里面有一个commit方法，用来触发mutations里面的方法

　5、mutations里面的方法用来修改state中的数据 mutations里面的方法都会接收到2个参数 一个是store中的state，另外一个是需要传递到参数

　6、当mutations中的方法执行完毕后state会发生改变，因为vuex的数据是响应式的 所以组件的状态也会发生改变(getter)

# 24. 浏览器渲染过程

（1）解析HTML，生成DOM树，解析CSS，生成CSSOM树

（2）将DOM树和CSSOM树结合，生成渲染树(Render Tree)

（3）Layout(回流，重排):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

（4）Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素

（5）Display:将像素发送给GPU，展示在页面上。

 

1、DNS解析

2、TCP连接，三次握手，建立socket，HTTP请求

3、负载均衡： 

4、服务器，返回页面

5、浏览器渲染DOM Tree、CSS Rule Tree等等

6、静态资源加载，重新请求，严格来说算第二部分。

   ![browserRender](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/browserRender.png)

# 25. 正则表达式

\d数字  \w一个数字或字母  例：”00\d”匹配”006”

.匹配任意字符  *匹配任意个字符包括0  +至少一个字符  ?0或1个字符

{n,m}n-m个字符 {n}表示n个字符  例：\d{3,8}匹配3-8个数字

A|B 匹配A或者B

^开头 $结束

s.replace(/(\s*)/g, "")

# 26. 静态类型检测flow、typescript

静态类型语言（statically-typed languages）会在编译时（compile time）进行类型检查，而动态语言（dynamically-typed）则是在运行时进行类型检查（runtime）。

# 27. 图形题

两个关键因素：数量关系 图形转动

对称 旋转 闭合区域 翻转 数量关系（等差 和） 权重 几种不同的类型 找共同点 规律不一定一样 整体的共性 元素个数

# 28. 前后端常用的几种鉴权方式

博客：<https://blog.csdn.net/wang839305939/article/details/78713124>

**1、HTTP Basic Authentication**

这种授权方式是浏览器遵守http协议实现的基本授权方式。HTTP协议进行通信的过程中，HTTP协议定义了基本认证，允许HTTP服务器对客户端进行用户验证。

1、客户端向服务器请求数据，客户端未验证，请求中未包含认证信息。

2、服务器收到后，向客户端发送验证请求（状态码401 unauthorized，表示发送的请求需要通过 HTTP 认证）

3、符合http规范的客户端会自动弹出一个登录窗口，要求输入用户名和密码。

4、用户输入后，浏览器将用户信息以BASE64加密方式加密，并将密文加入前一条请求中发送。Authorization: Basic d2FuZzp3YW5n

5、服务器收到请求后，将Authorization字段后的用户信息取出解密，将解密后的信息与数据库信息进行比较验证，验证成功后将资源发送给客户端。

加密方式简单，并且每个请求头上都会带上用户身份信息，很容易造成安全问题，所以适合用在安全要求不高的系统上。

**2、session-cookie**

利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，http是无状态的，如果我们要记录状态，就要在服务器端创建一个会话。过程：客户端首次请求，服务器端创建session，并保存，然后生成一个唯一标识符；将sessionId返回，浏览器取出sessionId存在cookie中；浏览器在下次请求的请求头中会带上该域名下的cookie信息；服务器根据cookie中的sessionId进行验证，返回资源。

   ![session](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/session.png)

**3、Token验证**

主流，App鉴权，微信授权等。

\1. 客户端使用用户名跟密码请求登录

\2. 服务端收到请求，去验证用户名与密码

\3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端

\4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里

\5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token

\6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

 

与session的区别

1、sessionId是一个唯一标识符，服务器根据这个标识符查询在服务器端保持的session，用户登录状态保存在session中；token是一种登陆成功凭证，本身就保存着用户登录状态，服务器端只是校验token是否合法。

2、session需要cookie配合，所以客户端只能是浏览器，只有浏览器才会解析请求响应头中的cookie，并在下次请求中带上该域名下的cookie。token不受客户端限制，可以与App交互。

3、session-cookie的sessionid是在登陆的时候生成的而且在登出时是一直不变的，在一定程度上安全就会低，而token是可以在一段时间内动态改变的。

JWT（JSON WEB TOKEN）：JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成json对象，然后对这个对象进行某中方式的加密，返回给客户端。

**4、 OAuth授权**

   ![OAuth](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/OAuth.jpg)

# 29. 自适应布局

flex，媒体查询，rem（html根元素字体大小），vw vh，开发两套代码，viewport，dpr（物理像素/独立像素），grid网格布局这些

 

设置视口：　

<meta name="viewport" content="initial-scale=1,maximum-scale=1,
minimum-scale=1">

动态设置html的font-size：

document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';

 

媒体查询+rem

@media screen and (min-width: 320px) {

    html {font-size: 16px}

}

@media screen and (min-width: 481px) and (max-width:640px) {

    html {font-size: 18px}

}

# 30. 两边固定中间自适应布局

1、flex布局

2、float：center元素必须在最后，左右预留出margin为宽度

3、position:absolute,左右预留出margin为宽度

4、calc(): 全部左浮动，用calc()计算中间元素宽度

# 31. 网络模型五层和七层

TCP/IP五层

OSI七层，OSI参考模型（OSI/RM）的全称是开放系统互连参考模型（Open SystemInterconnection Reference Model，OSI/RM）

![netModel01](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/netModel01.jpg)

   ![netModel02](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/netMeodel02.png)

   ![netModel03](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/netMeodel03.png)

   

 ![netModel04](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/netMeodel04.png)

# 32. http

http协议，超文本传输协议，是在tcp基础上实现的请求-响应模式的双向通信协议。在客户端-服务端架构上工作。属于网络七层模型中的应用层，默认是80端口。用请求方法包括get、put、delete、post。重要过程包括：传输的建立、请求的发起、响应的回传、连接的断开。

http是无状态的，对于事务处理没有记忆，每次请求都是独立的，服务器中不保存客服端的状态，每次请求客户端需要重新带上状态信息；http是无连接的，每次只处理一个请求，处理完成断开连接。

Content-type: <https://www.runoob.com/http/http-content-type.html>

   ![httpRequest](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/httpRequest.jpg)

   ![httpResponse](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/httpResponse.jpg)

   ![httpCode](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/httpCode.png)

**get,post区别**

1、get请求的数据会附在URL之后，post把提交的数据放在HTTP包的包体中

2、get提交的数据是有内存限制的（1024字节），而post理论上没有。

3、post安全性要比get高，get能被缓存（会被浏览器主动缓存），post不能。（GET请求在有些浏览器中会缓存，再次请求时，浏览器不会发送请求，而是使用上次请求获取到的结果。jquery中，将cache设置为false。它的工作原理是在GET请求参数中附加时间戳"_={timestamp}"）

4、get产生一个TCP数据包，POST产生两个数据包。

 

Connection: keep-alive要求服务器不要关闭tcp连接，客户端发送，服务端同样回应这个字段

http1.0中要手动加这个字段，http1.1中默认带上

 

**http1.1**

1、实现了持久连接，tcp默认不关闭，可以被多个请求复用，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。客户端在最后一个请求，发送Connection: close，明确要求服务器关闭TCP连接。

2、引入管道机制，允许在同一个tcp连接里面，客户端可以同时发送多个请求。

3、Content-Length:一个tcp可以传送多个回复，需要区分数据包是属于哪一个回应的，用Content-length声明本次回应的数据长度来区分不同的回应

4、分块传输编码：不一定要等到服务端处理完所有请求再返回，可以处理一块数据就返回一块数据

5、虽然允许复用tcp连接，但是同一个tcp连接里面，所有数据通信是按次序进行的，服务器只有处理完一个回应才会处理下一个。容易造成队头堵塞。

 

**http2**

https://juejin.im/post/5a4dfb2ef265da43305ee2d0

1、多工多路复用：在一个链接里，客户端和服务端可以同时发送多个请求或回应，不用按照顺序一一对应，避免“队头堵塞”

2、数据流：对数据包做标记，表明属于哪个回应，http2将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个唯一编号。奇数为客户端发出的，偶数为服务端的。可以指定数据流的优先级。

3、头信息压缩：一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

4、服务器推送：常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

 

# 33. TCP与UDP的区别（传输层协议）：

1、TCP可靠，稳定，在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

2、基于连接与无连接；

3、对系统资源的要求（TCP较多，UDP少，UDP程序结构较简单）；

4、TCP面向字节流，TCP把数据看成一连串无结构的字节流;UDP是面向报文的

5、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。tcp可靠适合少量数据，udp不可靠适合大量数据

6、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

 

# 34. http建立连接的过程，三次握手四次挥手

https://blog.csdn.net/qzcsu/article/details/72861891

1、为什么要三次握手，不是两次，最后还要有一次确认

2、为什么客户端最后还要等待2MSL？

3、为什么建立连接是三次握手，关闭连接确是四次挥手呢？

4、如果已经建立了连接，但是客户端突然出现故障了怎么办？

   ![connect](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/connect.png)

   ![closed](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/closed.png)

# 35. https原理

https://www.jianshu.com/p/ecbae815baf2

# 36. Websocket

https://www.runoob.com/html/html5-websocket.html

https://segmentfault.com/a/1190000014643900?utm_source=tag-newest

 

只需要一次握手

var Socket = new WebSocket(url, [protocol] );

Sec-WebSocket-Key：请求头， 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接

Sec-WebSocket-Accept：响应头，将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；通过 SHA1 计算出摘要，并转成 base64 字符串

send()：向服务器发送数据，文本字符串、Blob二进制

close()：关闭，window.onbeforeunload

事件（或者ws.addEventListener("message", func））

 ![websocket](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/websocket.png)

**websocket 轮询 长轮询 SSE**

长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接

轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。

长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。

WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表 明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。

SSE（Server-sent Events）：单向通道，只能服务器向客户端发送消息。与长轮询机制类似，区别是每个连接不只发送一个消息。客户端发送一个请求，服务端保持这个连接直到有新消息发送回客户端，仍然保持着连接，这样连接就可以消息的再次发送，由服务器单向发送给客户端。

# 37. webGL openGL canvas

Webgl技术结合了HTML5和JavaScript，允许开发者在网页上创建和渲染三维图形，canvas绘制图像。比较重要的，着色器语言GLSL ES。

![webGL](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/webGL.jpg)   

# 38. HTML5

  语义化更好的内容标签（header,nav,footer,aside,article,section）

  音频、视频标签(audio,video)

  画布(Canvas) API

  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除

  新的技术webworker, websocket, Geolocation

  地理(Geolocation) API

  表单控件，calendar、date、time、email、url、search

 

# 39. SVG与Canvas区别

1、SVG是矢量图，放大不失真，Canvas是位图，放大失真

2、VG基于基于XML的，是一种用于描述图形的XML语法，每个元素在SVG DOM中都可用。可以为每个元素添加JavaScript事件处理程序。适合用来绘制地图。Canvas是基于Js的，Canvas生成的图像可以保存为jpg或png。适合大型网络游戏。

3、SVG可以通过位移修改，Canvas修改需要重绘

# 40. CSS选择器

标签选择器 类选择器 id选择器 通配选择器 后代选择器 伪类选择器

# 41. CSS3

CSS3实现圆角（border-radius），阴影（box-shadow），

对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）

transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜。transform-origin：top left | left top 等价于 0 0 | 0% 0%

增加了更多的CSS选择器  多背景 rgba

在CSS3中唯一引入的伪元素是::selection.

媒体查询，多栏布局

border-image

animation transition

# 42. BFC

Formatting context(格式化上下文)是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

BFC 即 Block Formatting Contexts (块级格式化上下文),具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素,可以看做一个隔离的容器，可以用来解决上下margin塌陷问题，浮动父元素高度塌陷问题，子元素父元素margin塌陷问题

触发：body 根元素，浮动元素：float 除 none 以外的值，绝对定位元素：position (absolute、fixed)

display 为 inline-block、table-cells、flex，overflow 除了 visible 以外的值 (hidden、auto、scroll)

# 43. Js

几个重点：作用域、闭包、执行上下文、变量对象

强烈推荐：https://segmentfault.com/a/1190000012646488

JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。

动态：在运行时确定数据类型。数据类型可以改变

弱类：计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。（比如字符串与数字相加）

原型：新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。

 

**JavaScript由三部分组成**

1. ECMAScript（核心），描述JS的语法和基本对象，规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象

2. DOM（文档对象模型），处理网页内容的方法和接口，整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，删除、添加、替换或修改任何节点

3. BOM （浏览器对象模型），与浏览器交互的方法和接口，支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。

BOM有一个核心对象window，window对象包含了6大核心模块，分别是：

document对象，即文档对象

frames，即HTML自框架

history，即页面的历史记录

location，即当前页面的地址

navigator，包含浏览器相关信息

screen，用户显示屏幕相关属性

 ![BOM](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/BOM.jpg)

DOM 是文档对象模型，为了操作文档出现的 API，document 是其的一个对象，对浏览器（可看成容器）内的内容进行操作；

BOM 是浏览器对象模型，为了操作浏览器出现的 API，window 是其的一个对象，是对浏览器本身进行操作。

   

# 44. 事件循环

javascript是一门单线程语言，非阻塞，事件队列

Event Loop是javascript的执行机制

macro-task(宏任务)：主程序代码script，setTimeout，setInterval，setImmediate  I/O操作  UI渲染  requestAnimationFrame

micro-task(微任务)：Promise， MutationObserver process.nextTick() mutation Object.observe

宿主环境提供的叫宏任务，由语言标准提供的叫微任务

# 45. 执行环境，变量对象

执行上下文/执行环境（Execution Context）：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

执行上下文的代码会分成两个阶段进行处理：分析和执行，

executionContext：{

    variable object：vars,functions,arguments,
    
    scope chain: variable object + all parents scopes
    
    thisValue: context object

}

特点：单线程；同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待；全局上下文只有唯一的一个，它在浏览器关闭时出栈；函数的执行上下文的个数没有限制；每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

 

 VO变量对象（variable object）：每一个执行上下文都会分配一个变量对象(variable object)，它保存了当前作用域的所有函数和变量。变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。

VO = {

    arguments: {...},
    
    foo: <foo reference>, 
    
    a: undefined

}

创建过程：

建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。

检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。

检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

 

AO活动对象（activation object）：当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化。

 

未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。VO AO都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。

![EC01](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/EC01.png)      

![EC02](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/EC02.png)

# 46. ES5、ES6

<https://www.cnblogs.com/sunshinezjb/p/9248533.html>

ES5方法：严格模式、数组方法、对象方法、string.trim()、bind、JSON、Date.now()

   ![es](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/ES.png)

ES6

1、let、const，块级作用域，只在当前块起作用，不存在变量提升，let定义可以被改变的量，const定义常量，初始化的时候必须赋值，改变const常量的值会报错。

2、箭头函数，this的指向在定义的时候确定，获取上下文中的this

3、模板字符串

4、解构赋值

var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 

let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; 多层嵌套

let [, , z] = ['hello', 'JavaScript', 'ES6']  可以忽略一些元素

对象赋值

var person = {

    name: '小明',
    
    age: 20,
    
    gender: 'male',
    
    passport: 'G-12345678',
    
    school: 'No.4 middle school'

};

// 把passport属性赋值给变量id:

let {name, passport:id} = person;

// 不存在的默认赋值

var {name, single=true} = person;

// 先声明变量:

var x, y;

({x, y} = { name: '小明', x: 100, y: 200});

运用：（1）交换两个变量的值var x=1, y=2; [x, y] = [y, x]

（2）快速获取对象var {hostname:domain, pathname:path} = location;

5、for of

for (let value of arr) {

    console.log(value)

}

数组forEach、map方法的区别

ForEach相当于for循环，但是for循环中可以使用continue和break，forEach只能通过if语句return实现，return true为continue，return false为break

6、扩展运算符…，展开数组或对象

7、class

8、promise

9、moudle

10、Set：确定性 互异性 无序性

# 47. Promise

promise是为了解决异步编程的问题，通过链式调用使代码更加直观。首先，它有三种状态，pending进行中，fulfilled成功，rejected失败，根据执行结果，状态会凝固为成功或者失败，不会再改变。成功后进入then执行响应的回调函数，失败后错误被catch（catch相当于then(null,onRejected)）捕获。

Promise还有几种方法，promise.all()，接收一个Promise对象组成的数组作为参数，可以同时执行多个promise操作，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法，有一个发生错误就抛出异常，promise.race()只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了，promise.finally()不管成功还是失败都会执行。

# 48. new function过程

1. 创建空对象；

　var obj = {};

2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；

　obj.__proto__ = ClassA.prototype;

3. 使用新对象调用函数，函数中的this被指向新实例对象：

　ClassA.call(obj);　　//{}.构造函数();          

4. 将初始化完毕的新对象地址，保存到等号左边的变量中

var obj  ={};

obj.__proto__ = CO.prototype;

CO.call(obj);

return obj;

# 49. 构造函数

    function Foo(name, age){
    
        this.name = name
    
        this.age = age
    
        this.class = 'class-1'
    
        // return this //默认有这一行
    
    }

var f = new Foo('zhangsan', '20')

构造函数名首字母大写，

# 50. 原型原型链

   ![PROTOTYPE](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/prototype.png)

首先，原型有显式原型prototype和隐式原型__proto__两种，js中的对象都有__proto__，函数对象有prototype，当使用构造函数创建实例时，实例的__proto__（[[prototype]]）指向构造函数的prototype，构造函数的prototype原型是一个对象，它拥有自己的属性、对象、方法，它拥有一个constructor，指向当前构造函数。因为原型也是一个对象，也有自己的构造函数，构造函数的构造函数原型又会有自己的构造函数，这样一级级就形成原型链。当我们在实例中查找某一属性，实例中没有，就会去它的构造函数原型里查找，构造函数原型里没有，旧再去构造函数原型的构造函数原型里查找，这样就形成了链式结构。原型对象中的属性方法可以被它的实例共享，实现了继承。但是继承并不是严格的继承，并没有将原型复制一份给实例，只是建立了一种关联，实现属性共享。

原型和原型链中有几个关键的等式。

  Person.prototype = person._proto_

  Person.prototype.constructor = Person

  person.constructor = Person.prototype.constructor = Person // person中没有constructor,去原型中查找

原型链的顶端是Object()构造函数，object函数的原型指向null，表示没有原型。

# 51. 作用域作用域链this

作用域：程序源代码中定义变量的区域。确定当前执行代码对变量的访问权限，js采用词法作用域（静态作用域），在定义的时候确定

作用域链：由当前环境与上层环境的一系列变量对象组成，保证了当前执行环境对符合访问权限的变量和函数的有序访问。

作用域是指程序源代码中定义变量的区域，js采用词法作用域，也就是静态作用域，函数的作用域在函数定义的时候就确定了。

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的

全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。

call、apply、bind都是用来改变this指向的，call和apply的区别是，call的参数是一个序列，apply的参数是一个数组，他们两个是是立即执行的，bind是返回一个新函数，不是立即执行：xw.say.bind(xh)("实验小学","六年级")

# 52. 垃圾回收机制

<https://segmentfault.com/a/1190000018605776?utm_source=tag-newest>

没有被引用的对象就是垃圾，需要被清除。几个对象形成的闭环也是垃圾。

标记清除（从根节点开始，标记所有可达引用，没有被标记的就清除，浏览器默认），引用清除

https://blog.csdn.net/yingzizizizizizzz/article/details/77333996

# 53. 闭包

闭包：它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。

有权访问另一个函数作用域中的变量的函数,闭包的作用域链中存在父函数的变量对象

目的：使用闭包主要是为了设计私有的方法和变量。利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

闭包是由函数以及函数内部能访问到的变量组成。

特性:1.函数嵌套函数 2.内部函数可以访问外部函数的变量3、参数和变量不会被回收。

优点：1、避免全局变量污染，比如团队协作变量命名冲突 2、保护局部变量不被修改

缺点：1、常驻内存，使用不当会造成内存泄漏

销毁：引用不存在的时候，或者使用完函数及时清空fn = null

调试：在浏览器控制台Memory下创建快照，比对两次快照，找内存泄漏

# 54. 自执行函数

自执行函数：创建一个独立的作用域，作用域里面的变量，外面访问不到，避免变量污染。模块化的效果。

Jquery库。

# 55. 创建对象、继承的多种方式及优缺点

**// 创建对象的各种方式**

**// 1.工厂模式**

// 特点：有函数封装，返回创建的对象

// 缺点：无法识别对象类别

function createPerson(name) {

  var o = new Object();

  o.name = name;

  o.getName = function () {

    console.log(this.name)

  };

  return o;

}

var person1 = createPerson('May')

**// 2.构造函数模式**

// 1.没有显示地创建对象，直接将属性和方法赋值给this对象，没有return语句

// 优点：实例可以识别为一个特定的类型

// 缺点：每次创建实例，方法都要被创建一次

function Person () {

  this.name = name;

  this.getName = function () {

    console.log(this.name)

  }

}

var person1 = new Person();

**// 3.原型模式**

// 优点：方法不会被重新创建，缺点:所有属性和方法都被共享，不能初始化参数

function Person(name) {

};

Person.prototype.name = 'May';

Person.prototype.getName = function () {

  console.log(this.name);

};

var person1 = new Person()

**// 4、组合模式**

// 优点：结合构造函数模式和原型模式，对方法和一些公有属性共享，对私有属性私有

// 　　function 构造函数(){

//  　　　　this.属性;

//　　}

//　　构造函数.原型.方法=function(){};

//　　var 对象1=new 构造函数();

function Person(name) {

  this.name = name;

}

Person.prototype = {

  constructor: Person,

  getName: function () {

    console.log(this.name);

  }

}

var person1 = new Person();

// 其他创建对象的方式，动态原型模式，寄生构造函数模式，稳妥构造函数模式

 

**// 继承的方式**

**// 1.原型链继承**

// 缺点：引用类型的属性被所有实例共享(如数组)，构建Child实例时，不能向Parent传参

function Parent () {

  this.name = 'May';

};

Parent.prototype.getName = function () {

  console.log(this.name);

};

function Child () {

};

Child.prototype = new Parent();

var child1 = new Child();

**// 2.构造函数继承**

// 优点：避免了引用类型属性被实例共享，可以传参

// 缺点：方法在构造函数中定义，每次创建实例都会创建一次方法

function Parent (name) {

  this.name = name;

  this.names = ['May', 'Lindsay'];

}

function Child (name) {

  Parent.call(this, name);

}

var child1 = new Child('May');

**// 3.组合继承（原型链继承，构造函数继承）**

function Parent (name) {

  this.name = name;

  this.names = ['May', 'Lindsay'];

}

Parent.prototype.getName = function () {

  console.log(this.name);

}

function Child (name, age) {

  Parent.call(this, age);

  this.age = age;

}

Child.prototype = new Parent();

Child.prototype.constructor = Child;

var child1 = new Child('may', 18);

**// 4.原型式继承**

// 包含引用类型的属性值始终都会共享值

function createObj(o) {

    function F(){}
    
    F.prototype = o;
    
    return new F();

}

// 其他继承方式，寄生式继承，组合寄生式继承

 

// isPrototype()

function Animal () {

　  this.species = "动物";

};

var eh = new Animal();

Animal.prototype.isPrototypeOf(eh)//=>true

// hasOwnPrototype()

# 56.  js深拷贝

深拷贝是对于引用数据类型而言的。Js中有五种基本数据类型和引用数据类型。保存的地址不一样（详细见上）

浅拷贝只拷贝一层属性，深拷贝则是递归拷贝所有的属性。

**浅拷贝的实现：**

1、var new_arr = arr.concat()

2、var new_arr = arr.slice()

3、一层遍历

function simpleCopy(obj1) {

   var obj2 = Array.isArray(obj1) ? [] : {};

   for (let i in obj1) {

   obj2[i] = obj1[i];

  }

   return obj2;

}

4、Object.saaign()

let obj2 = Object.assign({},obj1)

6        var obj2 = Object.create(obj1)

Object.create =  function (o) {

    var F = function () {};
    
    F.prototype = o;
    
    return new F();

};

 

**深拷贝：**

**1、递归**

function deepCopy(obj1) {

      var obj2 = Array.isArray(obj1) ? [] : {};
    
      if (obj1 && typeof obj1 === "object") {
    
        for (var i in obj1) {
    
          var prop = obj1[i]; // 避免相互引用造成死循环，如obj1.a=obj
    
          if (prop == obj1) {
    
            continue;
    
          }
    
          if (obj1.hasOwnProperty(i)) {
    
            // 如果子属性为引用数据类型，递归复制
    
            if (prop && typeof prop === "object") {
    
              obj2[i] = deepCopy(obj1[i]); // 递归调用
    
            } else {
    
              // 如果是基本数据类型，只是简单的复制
    
              obj2[i] = prop;
    
            }
    
          }
    
        }
    
      }
    
      return obj2;
    
    }

**2、使用JSON.stringify和JSON.parse**实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象；

JSON.parse(JSON.stringify(obj))

1、它会抛弃对象的constructor，深拷贝之后，不管原来构造函数是什么，都会变成Object。2、只能处理Number，String，Boolean、Array，对Symbol，Function，undefined无法转换。

**3、jquery**

var obj2 = $.extend(true, {}, obj1)

# 57. js 类

类是创建对象的模板，是具有相同属性和方法的一组对象的集合。js严格来说没有类，而是通过一些方式模拟出类。js通过构造函数，利用原型来实现类的效果。本质就是创建函数对象。

ES6中类的写法是一个语法糖，类中的所有方法都定义在了prototype上，prototype对象的constructor属性也指向class类本身，被所有实例共享。不同的是，Class只能通过new操作符调用，不能像ES5中构造函数一样，当成普通函数调用。ES6的类和模块内部，默认严格模式，不存在变量提升。类内部定义的方法，都是不可枚举的。constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this）

**ES5 中定义一个类**

function Point(x, y) {

  this.x = x;

  this.y = y;

}

Point.prototype.toString = function () {

  return '(' + this.x + ', ' + this.y + ')';

};

var p = new Point(1, 2)

 

**ES6以后的语法（可以看做是ES5的语法糖）**

class Point {

  constructor(x, y) {   // 构造方法

    this.x = x;  // this关键字代表实例对象
    
    this.y = y;

  }

  toString() {

    return '(' + this.x + ', ' + this.y + ')';

  }

}

// 等同于

Point.prototype = {

  toString(){}；

};

typeof Point // "function"

Point === Point.prototype.constructor // true

# 58. 事件

（1）冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。

  IE 5.5: div -> body -> document

  IE 6.0: div -> body -> html -> document

  Mozilla 1.0: div -> body -> html -> document -> window

（2）捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。

（3）DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。

  DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。

# 59. Js异常捕获

常见的js异常捕获一般有2中方式：

1、try..catch

无法捕捉到语法错误，只能捕捉运行时错误；可以拿到出错的信息，堆栈，出错的文件、行号、列号；需要借助工具把所有的function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。

2、 window.onerror

JS脚本里边存着语法错误；JS脚本在运行时发生错误

# 60. 立即执行函数

不必为函数命名，避免了污染全局变量

立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量

封装变量

# 61. 内存泄漏，内存溢出

内存溢出： 指程序申请内存时，没有足够的内存供申请者使用

内存泄露 ：是指程序在申请内存后，无法释放已申请的内存空间就造成了内存泄漏，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

 

我们知道了内存泄漏的原因而内存溢出则有可能是因为我们我们多次内存泄漏堆积后的后果则变成了内存溢出

1、闭包

2、函数中未声明的变量会提升为windows对象

3、定时器等，回调函数及内部依赖的变量都不能被回收，需要手动销毁

# 62. Jquery

// js

var btn = document.getElementById('btn')

btn.setAttribute('disabled', 'disabled');

btn.removeAttribute('disabled')

// jquery

var btn = $('#btn')

btn.attr('disabled', 'disabled');

btn.removeAttr('disabled')

 

# 63. CSS animation

@keyframes myfirst

{

  0%   {background: red; left:0px; top:0px;}

  25%  {background: yellow; left:200px; top:0px;}

  50%  {background: blue; left:200px; top:200px;}

  75%  {background: green; left:0px; top:200px;}

  100% {background: red; left:0px; top:0px;}

}

 

animation-name: myfirst;

animation-duration: 5s;

animation-timing-function: linear;

animation-delay: 2s;

animation-iteration-count: infinite;

animation-direction: alternate;

animation-play-state: running;

transition和animation区别

<https://blog.csdn.net/XIAOZHUXMEN/article/details/52003135>

transition 需要事件触发（hover js 媒体查询），只执行一次，除非再次触发事件，只能设置其实和终止状态样式

animation 可以立即执行，循环播放，对动画过程的控制粒度更细

https://cn.vuejs.org/v2/guide/transitions.html

# 64. console.log()调试输出是异步的

对于基本数据类型是没有问题的，对object会出问题，打印的是指针，点击展开后会重新获取值，这个时候获取到的可能就是已经修改过的。

可以用JSON.stringify强制执行一次“快照”。最好还是用断点调试。

  const arrr = Array(3).fill(null).map(()=>{

    return Array("ab".length+1).fill(null);

  })

  console.log(arrr)

  console.log(JSON.stringify(arrr));

  arrr[0] = true;

# 65. 防抖节流

解决频繁触发函数带来的问题

防抖debounce：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，只有足够的空闲时间才执行一次代码，比如坐公交车刷卡，等没人刷卡司机才开车。

function debounce (fn, delay) {

  var timer = null;

  return function () {

    clearTimeout(timer);
    
    timer = setTimeout(function() {
    
      fn.apply(this)
    
    }, delay)

  }

}

第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码，第二次调用，就清除前一次的定时器并设置另一个，如果前一个已经执行过，这个操作没有意义，如果前一个没有执行，就替换为一个新的定时器

节流throttle：一定时间内只执行一次

function throttle (fn, delay) {

  var lastTime = 0;

  return function () {

    var nowTime = Data.now();
    
    if (nowTime - lastTime > delay) {
    
      fn.call(this);
    
      lastTime = nowTime;
    
    }

  }

}

# 66. 浏览器路由hash history

单页面应用（SPA），只有一个主页面的应用，一开始加载所有资源，所有的页面都包含在主页面内，但是写的时候分开写，在交互的时候由路由动态载入。

hash的原理是通过监听hash变化执行对应的操作。hash发生变化的url会被浏览器记录下来，这样就可以实现前进后退。hash值的变化不会导致浏览器向服务器发出请求。

window.onhashchange = function(event){

     console.log(event.oldURL, event.newURL);
    
     let hash = location.hash.slice(1); 
    
     document.body.style.color = hash;

}

history API，没有#符号，但是不能刷新，刷新会去请求服务器，需要服务器配合否则会发生错误。hash模式中，前端修改#后面的路由信息，但是浏览器请求的时候不带#后面的，所以刷新没问题。

history.back() forward() go(num)

H5新增方法

history.pushState(data[,title][,url]); // 向历史记录中追加一条记录

history.replaceState(data[,title][,url]); // 替换当前页在历史记录中的信息。history.pushState({color:'red'}, 'red', 'red')

通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到state的里面。

        //防止页面后退
    
        history.pushState(null, null, document.URL);
    
        window.addEventListener('popstate', function () {
    
            history.pushState(null, null, document.URL);
    
        });

# 67. Position

absolute 

生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

fixed      

生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

relative  

生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。

static

默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

sticky     

粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。

# 68. Hybrid App及开发方式Weex React-Native Flutter

Hybrid App可以充分利用原生的优势，调用底层接口，又可以发挥前端开发的灵活性，做到一套前端代码多出运行，提高了开发效率，并且有些更新不需要用户去应用应用更新。

# 69. mysql和mongodb的区别

MySQL是传统的关系型数据库，MongoDB则是非关系型数据库

mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。

对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：一致性（最终一致），更能保证用户的访问速度；文档结构的存储方式，能够更便捷的获取数据。

# 70. 前端优化

首屏优化

vue-router懒加载（按需加载），CDN加速，异步加载组件，服务端渲染

 

**从用户角度考虑，主要是页面加载过程的优化！！！**

https://www.cnblogs.com/xiaohuochai/p/9178390.html

**减少http****请求：**合并（CSS、JS文件打包，CSS sprite），字体图标库代替图片，使用缓存

**减少资源大小：**HTML、CSS、JS、图片压缩，gzip

**优化网络连接：**CDN，持久连接（keep-alive）

**优化资源加载：**通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用，JS文件放在body底部，先外链，后本页；模块按需加载

 

（1）图片懒加载 自定义data-src属性

<img src="loading-img" alt="1"
data-src="imgsrc">）。

（2）axios拦截器，统一增加请求头，减少冗余代码

  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

  （4） 当需要设置的样式很多时设置className而不是直接操作style。避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。避免使用高级选择器，通配选择器。

  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

  （6） 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。

# 71. ecahrts Bmap

# 72. 排序算法及实现

**冒泡排序**

function bubble (arr) {

  if (arr.length <= 1) return;

  var temp;

  var marker = 0;

  for (var i = 0; i < arr.length; i++) {

    for(var j = 0; j < arr.length - i - 1; j++) {
    
      if (arr[j] > arr[j+1]) {
    
          temp = arr[j];
    
          arr[j] = arr[j+1];
    
          arr[j+1] = temp;
    
          marker = 1;
    
      }
    
    }
    
    if (!marker) {
    
      break;
    
    }

  }

  return arr;

}

**快速排序**

function quick (arr) {

  if (!Array.isArray(arr)) {

    alert('请输入数组')

  }

  var len = arr.length;

  if (len <= 1) {return arr};

  var arr_left = [];

  var arr_right = [];

  var pivot = arr[0];

  for (var i = 1; i < len; i++) {

    arr[i] > pivot ? arr_right.push(arr[i]) : arr_left.push(arr[i]);

  }

  return quick(arr_left).concat(pivot).concat(quick(arr_right));

}

 

var arr=[5,7,2,9,3,8,4,7,1];

// 每次选择最左边的数作为基数

function quickSort(arr){

  if (arr.length<2) { return arr; }

  // 定义左指针

  var left=0;

  // 定义右指针

  var right=arr.length-1;

  //开启每一轮的排序

  while(left<right){

    // 寻找右边比arr[0]小的数的下标
    
    while(arr[right]>=arr[0] && left<right){
    
      right=right-1;
    
    }
    
    // 寻找左边比arr[0]大的数的下标
    
    while(arr[left]<=arr[0] && left<right){
    
      left++;
    
    }
    
    //当左边指针与右边指针相遇后，交换arr[0]与当前两个指针所在的元素
    
    if (right==left) {
    
      let mid=arr[right];
    
      arr[right]=arr[0];
    
      arr[0]=mid;
    
      break;
    
    }
    
    // 当左指针小于右指针的位置，交换两个指针当前位置的元素
    
    let tem=arr[right];
    
    arr[right]=arr[left];
    
    arr[left]=tem;

  }

  //递归实现

  return quickSort(arr.slice(0,left)).concat(arr.slice(left,right+1)).concat(quickSort(arr.slice(right+1)));

}

//对数组进行排序

console.log(quickSort(arr));

# 73. 设计模式

设计模式总共有23种，根据目的准则分类，分为三大类。

**创建型设计模式**（顾名思义就是和对象的创建有关，共5种）：单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式。

**结构型设计模式**（从程序的结构上解决模块之间的耦合问题，共7种）：适配器模式，装饰者模式，代理模式，外观模式，桥接模式，组合模式，享元模式。

**行为型设计模式**（处理类或者对象如何交互，如何分配职责，11种）：策略模式，模板方法模式，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。

JS常用设计模式

<https://blog.csdn.net/qq_42564846/article/details/81583342>

<https://juejin.im/entry/58c280b1da2f600d8725b887>

https://segmentfault.com/a/1190000017787537?utm_source=tag-newest

观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

 

在Observer模式中，Observers知道Subject，同时Subject还保留了Observers的记录。在发布者/订阅者中，发布者和订阅者不需要彼此了解。他们只是在消息队列或代理的帮助下进行通信。

在Publisher / Subscriber模式中，组件是松散耦合的，而不是Observer模式。

观察者模式主要以同步方式实现，即当某些事件发生时，Subject调用其所有观察者的适当方法。发布者/订阅者在大多情况下是异步方式（使用消息队列）。

观察者模式需要在单个应用程序地址空间中实现。另一方面，发布者/订阅者模式更像是跨应用程序模式。

# 74. MVVM MVP MVC

**MVVM（Model-View-ViewModel）**

模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。MVVM流程图如下：

   ![mvvm](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/MVVM.png)

**MVC（Model-View- Controller）**

模型-视图-控制器，C即Controller指的是页面业务逻辑。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。是一种将业务逻辑、界面显示、数据存储分离开来的方法组织框架。

   ![MVC](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/MVC.png)

**MVP（Model-View-Presenter）**

Presenter将View与Model分离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。所有的业务逻辑由Presenter主持者来控制。

 

<http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io>

 

MVVM和MVC设计模式的区别

MVVM中的View 和 ViewModel可以互相通信。也就是可以互相调用。

MVC中的是单向通信。也就是View跟Model，必须通过Controller来承上启下

MVVM全称是Model-View-ViewModel

Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。

# 75. Vue渐进式

   ![Vue](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/Vue.jpg)

https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485737&amp;idx=1&amp;sn=14fe8a5c72aaa98c11bf6fc57ae1b6c0&source=41#wechat_redirect

Progressive 一步一步的，可以自底向上逐层应用，vue的核心库是声明式渲染和组件系统，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。框架做分层设计，每层都可选，不同层可以灵活接入其他方案。

这样的一个配置方案，在构建技术栈的时候有可弹性伸缩的工具复杂度：当所要解决的问题内在复杂度很低的时候，可以只用核心的这些很简单的功能；当需要做一个更复杂的应用时，再增添相应的工具。例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。

# 76. vue双向绑定原理

<https://www.cnblogs.com/wangjiachen666/p/9883916.html>

<https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96>

数据劫持+订阅发布模式

Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。当把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。

Vue内部通过Object.defineProperty方法属性拦截的方式，把data对象里每个数据的读写转化成getter/setter，当数据变化时通知视图更新。

双向绑定，视图变化更新数据可以通过事件监听实现，所以我们重点讨论数据变化更新视图（model => view）

1、observer：首先要使数据对象变得“可观测”，用Object.defineProperty方法改写数据对象的getter和setter,这样数据对象就可以主动告诉我们它的属性读写情况了。

    let car = {}
    
    let val = 3000
    
    Object.defineProperty(car, 'price', {
    
        get(){
    
            console.log('price属性被读取了')
    
            return val
    
        },
    
        set(newVal){
    
            console.log('price属性被修改了')
    
            val = newVal
    
        }
    
    })

2、Dep、Watcher：监听到数据变化，就要通知依赖去更新视图，首先用一个消息订阅器Dep管理这些依赖，收集订阅者。将订阅器Dep添加订阅者的操作设计在getter里面，这是为了让Watcher初始化时进行触发。

3、Compile，对于每个元素上的指令进行解析，根据指令替换数据，更新视图。

   ![Vue-MVVM01](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/Vue-MVVM01.png)

   ![Vue-MVVM02](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/Vue-MVVM02.png)

# 77. keep-alive组件

<https://github.com/qiudongwei/blog/issues/4>

1、<keep-alive>是Vue的内置组件，作用是在组件切换过程中，缓存组件，保持组件状态，防止重复渲染DOM，合理使用keep-alive可以提升系统性能。

2、<keep-alive>是一个抽象组件，不会在dom树中渲染（真实或者虚拟dom都不会）。

3、prop:

include: 字符串或正则表达式。只有匹配的组件会被缓存。

exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。

exclude优先级大于include

4、router中设置meta信息，<router-view v-if="$route.meta.keepAlive">配合使用，控制是否缓存

5、keep-alive生命周期钩子函数：activated、deactivated

    使用<keep-alive>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。

　　被包含在 <keep-alive> 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated

    activated：在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。

　　deactivated：在组件被停用时调用。

　　当引入keep-alive 的时候，页面第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。

**原理：**

Vue内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。

created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点

created{

    this.cache=Object.create(null);

}

destroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。

destroyed () {

    for (const key in this.cache) {
    
        pruneCacheEntry(this.cache[key])
    
    }

# 78. VUE组件封装

1、使用Vue.extend()创建一个组件

调用Vue.extend()，创建名为myCom的组件

var myCom = Vue.extend({

    template: '<div>这是我的组件</div>'

})

 

2、使用Vue.component()方法注册组件

全局注册：一次注册( 调用Vue.component( 组件名称，为组件创建时定义的变量 ) )，可在多个Vue实例中使用。

局部注册：只能在注册该组件的实例中使用，一处注册，一处使用

// 不需要注册直接创建

Vue.component('my-com',{

    'template':'<div>这是我的组件</div>'

})

3、如果子组件需要数据，可以在props中接受定义

4、子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法

 

        /*创建组件*/
    
        var myCom = Vue.extend({
    
            template: '<div>这是我的组件</div>'
    
        });
    
        /*全局注册组件*/
    
        Vue.component('my-com',myCom);

 



        /*定义vue实例app1*/
    
        var app1 = new Vue({
    
            el: '#app1'
    
        });

 



写法参考

https://blog.csdn.net/ywl570717586/article/details/79984909

import Vue from 'vue';

import MyComponent from '@/components/MyComponent.vue'; // 导入自己写的组件文件

Vue.use(MyComponent); // 自定义全局组件的时候需要Vue.use();

Vue.component('my-component', MyComponent); //初始化组件

new Vue({

  el: '#app',

  router,

  components: {

    App,
    
    MyComponent

  },

  template: '<App/>',

});

# 79. vue生命周期

vue生命周期是Vue实例从创建、运行到销毁的的一个过程，vue提供了8个钩子函数让用户在对应阶段处理一些自定义事件

 \- 创建期间的生命周期函数：

      \+ beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
    
      \+ created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板
    
      \+ beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中
    
      \+ mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示

 \- 运行期间的生命周期函数：

     \+ beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点
    
     \+ updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！

 \- 销毁期间的生命周期函数：

     \+ beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
    
     \+ destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

 



（1）beforeCreate：loading 事件 

（2）created：结束loading 事件、获取异步请求 

（3）mounted：挂载DOM 元素，获取DOM节点 

（4）beforeDestroy：做一个是否离开当前页的提示框，销毁定时器

   ![lifecycle](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/Vue-lifecycle.png)

# 80. watch、computed区别

都是依赖追踪，当依赖数据变化时，所有依赖这个数据的其他数据自动更新。

computed强调计算，一个数据受多个数据影响，返回一个复杂计算后的值，它关联多个实时计算对象。它有缓存能力，只有在依赖数据变化的时候才会重新计算，否则使用缓存，优化性能。vue模板内可以写一些简单的js表达式，但是不适合写复杂逻辑，所以用computed属性处理复杂逻辑。

watch强调监听和执行事件，一个数据影响多个数据

 

引申data

data不能持续追踪依赖，比如data的值也是一个变量时，变量的改变不会被data追踪到，而computed是会持续追踪变化的

# 81. vuex

管理页面数据状态，提供统一数据操作，任何组件都可以存取仓库中的数据。通过全局注入store对象，来实现组件间的状态共享。

vuex和全局变量的区别：

1，【响应式】vuex的状态存储是响应式的，当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新。

2，【不能直接改变store】不能直接改变store的变化，改变store中状态的唯一途径是commit mutation。方便于跟踪每一个状态的变化。

# 82. vue slot

匿名插槽，具名插槽，作用域插槽（父组件获取子组件的参数）

# 83. Vue-router

$route为当前router跳转对象，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象。

$router为VueRouter实例，全局的路由器对象，里面有很多属性和子对象，想要导航到不同URL，则使用$router.push方法

返回上一个history也是使用$router.go方法

this.$router.push({path:`/user/${userId}`})

这样传递参数的话，配置路由的时候需要在path上加参数path：user/：userId。

这种接收参数的方式是this.$route.params.userId。

# 84. Vue、react、angular

vue是模板渲染，react是函数式编程

# 85. Vue2.0 Vue3.0

    双向绑定3.0用proxy实现，因为objectdefineProperty优缺点，不能检测对象属性的添加删除，不能监听到数组下标的变化。

# 86. this.$nextTick

返回一个 Promise 对象，在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调。场景:基于新的视图进行操作，在回调中获取更新后的 DOM。

vue的dom更新是异步执行的，监听到数据变化，vue会开启一个队列，缓存在同一事件循环中发生的所有数据变更，如果同一个 watcher 被多次触发，只会被推入到队列中一次。等同一时间循环中的数据变化完成之后再去统一更新视图。

<https://www.jianshu.com/p/a7550c0e164f>

# 87. 视频协议RTMP HLS

RTMP协议（Real Time Messaging Protocol）是一种流媒体传输协议，是直播APP中最常用的流媒体传输协议，它最主要的优势就是低延时。

RTMP 协议进行数据传输时，它是一整条数据流被封装成FLV通过HTTP提供出去，因此在服务器不会有落地文件，基于 TCP 长连接，不需要多次建连，所以延时通常为 1-3s，远超HLS

 

HTTP Live Streaming协议被缩写为HLS，是苹果公司发布的基于HTTP的流媒体传输协议（因此苹果的所有系统都支持HLS）。

其工作原理是切片式传输，把直播流切成无数片，用户在观看视频时，每次客户端可以只下载一部分，然后在这部分播放时从许多不同的备用源中下载其他资源，因此HLS协议可以任由用户的意愿选择不同的码率。HLS基于 HTTP/80 传输，很少会被防火墙拦下。

# 88. Linux权限

第一位表示文件类型。d是目录文件，l是链接文件，-是普通文件，p是管道

第2-4位表示这个文件的属主拥有的权限，r是读，w是写，x是执行。

第5-7位表示和这个文件属主所在同一个组的用户所具有的权限。

第8-10位表示其他用户所具有的权限。

   ![linux](https://feiyu-notes.oss-cn-hangzhou.aliyuncs.com/linuxAuth.png)

# 89. SQL语句

顺序：where、group by、having、order by、limit

<https://blog.csdn.net/qq_27501261/article/details/79487884>

 

sql查询

# 90. 关系型数据库、非关系型数据库

非关系型数据库的优势：

性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。

可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

 

关系型数据库的优势：

复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。

事务支持：使得对于安全性能很高的数据访问要求得以实现。

# 91. 数据库事务性

<https://blog.csdn.net/l1394049664/article/details/81814090>

<https://www.cnblogs.com/sweety-fly/p/9397466.html>

# 92. nginx

静态资源服务器，反向代理，实现负载均衡，虚拟主机

# 93. 防止用户重复点击

1、button的disabled状态

2、添加标识，注意状态初始化

3、事件bind unbind $(".div").bind("click", foo)

# 94. 技术选型考虑什么

业务需求，业务体量，可扩展性，技术稳定性，技术社区生态

# 95. 怎么看前端发展、发展趋势

中后台

前台： C 端用户；

中台：第三方业务运营方，是公司把部分业务开放后，为别的公司的业务赋能

后台：公司内部的业务运营平台

前端包含：面向大众用户的，面向内部管理者的，重前端的用户可自主配置定制服务的（进行设计或者一些开发配置）

 

载体的变化：web，小程序，hybrid App，未来的各种终端设备，只要技术上可以打通都可以成为钱盾发展的方向。

从产品上看，小程序混合App这些多元化发展，还有传统pc端软件的网页化，webGL SVG Canvas

 

前端发展的瓶颈、弱点

大部分还是依赖浏览器，但是浏览器会有很多问题，兼容性问题，性能问题等等，性能上没有原生的好

# 96. 自己的规划，五年，三年

先适应环境，多向身边优秀的同时学习，深耕自己的方向，可以有独立带领团队的能力，同时了解一些后端的知识，拓展自己的知识面，同时根据自己的工作经验调整

# 97. 你有什么要问的

公司的培训机制（入职和以后），有没有内部学习系统；刚刚某个问题不明白的地方；部门和团队情况；薪资工作时间转正；